# -*- coding: utf-8 -*-
"""HenonMap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SOGCannf5OotC-vbOajdbXCUgXybaHLI

A Study about Chaotic Dynamics developed in the classroom on Introduction to Chaos - 4300320, ministerd by PhD Adriane da Silva Reis.

The Henon Map is a two dimensional attractor defined by a recurrence equation
\begin{equation}
    \begin{cases}
    & x_{i+1}=1-a\cdot x_i^2 + y_i \\ 
    & y_{i+1} = b \cdot x_i
    \end{cases}
\end{equation}

We can represent the last equation in the recurrence in two steps

\begin{equation}
    x_{i+1}=1-a\cdot x_{i} + b\cdot y_{i-1}
\end{equation}
"""

'''''''''
Library
'''''''''
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#This code plot a attractor from Henon Map

#Set a constants values
a=1.4
b=0.3
it=100000 #iterations

#Henon Map
def mhen(x,y): #equation recurrence
    xn=1-a*x**2+y
    yn=b*x
    return xn,yn

#Create lists and initial conditions
xt=np.zeros(it+1)
yt=np.zeros(it+1)
xt[0],yt[0]=0.5,0.2

#Calculates each value xt[i],yt[i] from i=0 to it
for i in range(it): 
    xk,yk=mhen(xt[i],yt[i])
    xt[i+1]=xk
    yt[i+1]=yk

#data=pd.DataFrame({'Eixo x':xt,'Eixo y':yt})
#print(data)



#Settings to plot a Graphic
plt.style.use('dark_background')
plt.figure(figsize = (18,12))
plt.plot(xt,yt,',',color='white',markersize=0.3)
plt.xlim([-1.5,1.5])
plt.xlabel(r'$x_n$')
plt.ylabel(r'$y_n$')
plt.show()


#Zooms to see a fractal dimensional

'''
#Original Image
plt.figure(figsize = (18,12))
plt.plot(xt,yt,',',color='black',markersize=0.3)
plt.plot([0.4,0.4,0.6,0.6,0.4],[0.1,0.3,0.3,0.1,0.1],color='black',markersize=0.3)
plt.xlim([-1.5,1.5])
plt.xlabel(r'$x_n$')
plt.ylabel(r'$y_n$')
plt.show()

#Zoom 1
plt.figure(figsize = (18,12))
plt.plot(xt,yt,',',color='black',markersize=0.3)
plt.plot([0.425,0.425,0.525,0.525,0.425],[0.125,0.225,0.225,0.125,0.125],color='black',markersize=0.3)
plt.ylim([0.15,0.3])
plt.xlim([0.4,0.6])
plt.xlabel(r'$x_n$')
plt.ylabel(r'$y_n$')
plt.show()

#Zoom 2
plt.figure(figsize = (18,12))
plt.plot(xt,yt,',',color='black',markersize=0.3)
plt.plot([0.46,0.46,0.48,0.48,0.46],[0.20,0.22,0.22,0.20,0.20],color='black',markersize=0.3)
plt.ylim([0.125,0.225])
plt.xlim([0.425,0.525])
plt.xlabel(r'$x_n$')
plt.ylabel(r'$y_n$')
plt.show()

#Zoom 3
plt.figure(figsize = (18,12))
plt.plot(xt,yt,',',color='black',markersize=0.3)
plt.ylim([0.20,0.22])
plt.xlim([0.46,0.48])
plt.xlabel(r'$x_n$')
plt.ylabel(r'$y_n$')
plt.show()

#plt.style.use('dark_background')
'''

#This code plot a Bifurcation Diagram from Henon Map for each value a with b 
#constant

#Set a constants values and initial conditions
x0=-1
xi=-1
b=0.3
it = 100 #Iterations
e=500 #Evoltion: How much values x its calculated for r
t=200 #Transient: How much iterations whill the function do before returning xn


#Functions
def Hen(x,xi,a,b): #Is a equation recurrence in two steps
    return 1-a*(x**2)+b*xi
def transi(xn,xni,a,b): #This function calculate value of xn each r
    for i in range(int(t)):
        xk=np.copy(xn) #Save a copy of xn in xk
        xn=Hen(xn,xni,a,b) #xn=x_{i} and xni=x_{i-1}
        xni=xk #Now x_{i-1}=xk
    return xn,xni #Return news values from xn=x_{i} and xni=x_{i-1}

#Lists
xn=[x0]#xn=x_{i+1}
xni=[xi]#xni=x_{i-1}
xn1=[Hen(xn[0],xni[0],1.4,b)]#Calculate the new xn1=x_n{i+1}
xni=np.copy(xn)#Now xni=x_{i-1} is a copy from xn=x_{i+1}
xn.append(xn1[0])#xn is the xn1[0]
xn1.append(xn1[0])#Duplicate value xn1[0] in list xn1
A=np.linspace(0,1.4,500) #Create a set in the range [1,4], with 200 elements
at=[] #Receive each value from A
xt=[] #Receive each x_{i+1} calculated on each element A 


#This "for" calculated the values x in Henon map for the "e" evolutions after 
#transient "t", in function of all elements in the set A

for i in range(len(A)): 
    x = transi(x0,xi,A[i],b)[0] #x=x_{i+1}
    xi=transi(x0,xi,A[i],b)[1] #x=x_i
    for j in range(e):
        xk=np.copy(x)
        x = Hen(x,xi,A[i],b)
        xi=xk
        at.append(A[i])
        xt.append(x)

#data=pd.DataFrame({'Lista a':at,'Lista x':xt})
#print(data)


#Settings to plot a Graphic
fig = plt.figure(figsize = (18,12))
plt.style.use('dark_background')
plt.title("Mapa de Hénon em função da variável A")
plt.plot(at,xt,'.w',alpha=0.8,markersize=0.3)
plt.show()

#This code plot a Bifurcation Diagram from Henon Map for each value a with a 
#constant

#Set a constants values and initial conditions
x0=0
xi=0
a=1.4
it = 100 #Iterations
e=500 #Evoltion: How much values x its calculated for r
t=200 #Transient: How much iterations whill the function do before returning xn


#Functions
def Hen(x,xi,a,b): 
    return 1-a*(x**2)+b*xi
def transi(xn,xni,a,b):
    for i in range(int(t)):
        xk=np.copy(xn)
        xn=Hen(xn,xni,a,b)
        xni=xk
    return xn,xni

#Lists
xn=[x0]
xni=[xi]
xn1=[Hen(xn[-1],xni[-1],a,b)]
xni=np.copy(xn)
xn.append(xn1[-1])
xn1.append(xn1[-1])
B=np.linspace(-0.39999,0.3,500) #Cria um conjunto no intervalo [1,4], com 200 elementos
bt=[] 
xt=[]


#This "for" calculated the values x in Henon map for the "e" evolutions after 
#transient "t", in function of all elements in the set A

for i in range(len(B)):
    x = transi(x0,xi,a,B[i])[0] 
    xi=transi(x0,xi,a,B[i])[1] 
    for j in range(e):
        xk=np.copy(x)
        x = Hen(x,xi,a,B[i])
        xi=xk
        bt.append(B[i])
        xt.append(x)

#data=pd.DataFrame({'Lista b':bt,'Lista x':xt})
#print(data)

#Settings to plot a Graphic
fig = plt.figure(figsize = (18,12))
plt.style.use('dark_background')
plt.title("Mapa de Hénon em função da variável B")
plt.plot(bt,xt,'.w',alpha=0.5,markersize=0.1)
plt.show()